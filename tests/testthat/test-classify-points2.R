# library(testthat)
# library(dplyr)
# library(sf)
# # # library(hydrofabric3D)
# 
# source("testing_utils.R")
# # source("tests/testthat/testing_utils.R")
# # devtools::load_all()
# 
# # -------------------------------------------------------------------
# # ---- hydrofabric3D::classify_points() ----
# # -------------------------------------------------------------------
# 
# # TODO:
# testthat::test_that("check CLASSIFIED CS points default output columns, from DEFAULT transects output", {
#   
#   flowlines    <- sf::read_sf(testthat::test_path("testdata", "flowlines.gpkg"))
#   # flowlines    <- dplyr::slice(flowlines, 1)
#   
#   MIN_BF_WIDTH       <- 50
#   ID_COL             <- "hy_id"
#   NUM_OF_TRANSECTS   <- 3
#   
#   # Cross section point inputs
#   DEM_PATH          <- testthat::test_path("testdata", "dem_flowlines.tif")
#   POINTS_PER_CS     <- NULL
#   MIN_PTS_PER_CS    <- 10
#   
#   PCT_OF_LENGTH_FOR_RELIEF <- 0.01
#   
#   flowlines <-
#     flowlines %>% 
#     dplyr::slice(1) %>%
#     # dplyr::slice(1:3) %>% 
#     add_powerlaw_bankful_width("tot_drainage_areasqkm", MIN_BF_WIDTH) %>%  
#     dplyr::rename(!!sym(ID_COL) := id) %>% 
#     dplyr::select(
#       dplyr::any_of(ID_COL), 
#       tot_drainage_areasqkm,
#       bf_width,
#       geom
#     ) 
#   
#   transects <- cut_cross_sections(
#     net = flowlines,
#     id  = ID_COL,  
#     num = NUM_OF_TRANSECTS
#   )
#   
#   transects <- dplyr::select(transects,
#                              dplyr::any_of(ID_COL),
#                              cs_id,
#                              cs_lengthm
#   )
#   
#   cs_pts = hydrofabric3D::cross_section_pts(
#     cs              = transects,
#     crosswalk_id    = ID_COL,
#     points_per_cs   = POINTS_PER_CS,
#     min_pts_per_cs  = MIN_PTS_PER_CS,
#     dem             = DEM_PATH
#   )
#   # cs_pts
#   # cs_pts  %>% 
#   # # dplyr::select(hy_id, cs_id, pt_id, Z, relative_distance)  %>% 
#   # sf::st_drop_geometry() %>%
#   # classify_points(
#   #   cs_pts = cs_pts,
#   #   crosswalk_id = ID_COL,
#   #   pct_of_length_for_relief = PCT_OF_LENGTH_FOR_RELIEF
#   # ) %>% 
#   #   hydrofabric3D::plot_cs_pts(color = "point_type", size = 4)
#   # 
#   # classify_points(
#   #   cs_pts = cs_pts,
#   #   crosswalk_id = ID_COL,
#   #   pct_of_length_for_relief = PCT_OF_LENGTH_FOR_RELIEF
#   # ) %>% 
#   #   hydrofabric3D::plot_cs_pts(color = "point_type", size = 4)
#   
#   classified <- classify_points(
#     cs_pts = cs_pts,
#     crosswalk_id = ID_COL,
#     pct_of_length_for_relief = PCT_OF_LENGTH_FOR_RELIEF
#   ) 
#   
#   # check if minimum required output columns 
#   testthat::expect_true(
#     classified_cs_pts_has_min_output_cols(classified_pts = classified, id = ID_COL)
#   )
#   
#   # check that if NO 'id' is specified, then the default output columns will NOT match the classified points that DID have a specified 'id' 
#   testthat::expect_false(
#     classified_cs_pts_has_min_output_cols(classified_pts = classified )
#   )
#   
#   # test same number of input points are in classified output points 
#   same_num_pts_after_classifying <- nrow(cs_pts)  == nrow(classified)
#   testthat::expect_true(same_num_pts_after_classifying)
#   
#   # make sure all the unique tmp_ids (id + cs_id) are the same in the input AND output 
#   same_unique_tmp_ids <- has_same_unique_tmp_ids(x = cs_pts, y = classified, id = ID_COL)
#   testthat::expect_true(same_unique_tmp_ids)
#   
# })
# 
# 
# # TODO:
# testthat::test_that("check 'valid_banks' attribute of CLASSIFIED CS points from DEFAULT transects output", {
#   
#   flowlines    <- sf::read_sf(testthat::test_path("testdata", "flowlines.gpkg"))
#   # flowlines    <- dplyr::slice(flowlines, 1)
#   
#   MIN_BF_WIDTH       <- 50
#   ID_COL             <- "hy_id"
#   NUM_OF_TRANSECTS   <- 3
#   
#   # Cross section point inputs
#   DEM_PATH          <- testthat::test_path("testdata", "dem_flowlines.tif")
#   POINTS_PER_CS     <- NULL
#   MIN_PTS_PER_CS    <- 10
#   
#   PCT_OF_LENGTH_FOR_RELIEF <- 0.01
#   
#   flowlines <-
#     flowlines %>% 
#     # dplyr::slice(1) %>%
#     # dplyr::slice(1:3) %>% 
#     add_powerlaw_bankful_width("tot_drainage_areasqkm", MIN_BF_WIDTH) %>%  
#     dplyr::rename(!!sym(ID_COL) := id) %>% 
#     dplyr::select(
#       dplyr::any_of(ID_COL), 
#       tot_drainage_areasqkm,
#       bf_width,
#       geom
#     ) 
#   
#   transects <- cut_cross_sections(
#     net = flowlines,
#     crosswalk_id  = ID_COL,  
#     num = NUM_OF_TRANSECTS
#   )
#   
#   transects <- dplyr::select(transects,
#                              dplyr::any_of(ID_COL),
#                              cs_id,
#                              cs_lengthm
#   )
#   
#   cs_pts = hydrofabric3D::cross_section_pts(
#     cs              = transects,
#     crosswalk_id    = ID_COL,
#     points_per_cs   = POINTS_PER_CS,
#     min_pts_per_cs  = MIN_PTS_PER_CS,
#     dem             = DEM_PATH
#   )
#   
#   # cs_pts <- 
#     # cs_pts %>% 
#     # dplyr::filter(hy_id == "wb-1003258", cs_id == 1)
#   
#   classified <- classify_points(
#     cs_pts = cs_pts,
#     crosswalk_id = ID_COL,
#     pct_of_length_for_relief = PCT_OF_LENGTH_FOR_RELIEF
#   ) 
#   # classify_points(
#   #   cs_pts = cs_pts,
#   #   crosswalk_id = ID_COL,
#   #   pct_of_length_for_relief = PCT_OF_LENGTH_FOR_RELIEF
#   # ) %>% 
#   #      plot_cs_pts(color = 
#   #                 "point_type", size = 4)
#   # 
#   # classified %>% 
#   #   plot_cs_pts(color = 
#   #                 "point_type", size = 4)
#   
#   true_valid_banks <- 
#     classified %>% 
#     dplyr::filter(valid_banks) %>% 
#     # dplyr::slice(1:10) %>% 
#     dplyr::group_by(hy_id, cs_id)  %>% 
#     dplyr::mutate(
#       double_check_valid_banks = dplyr::case_when(
#         ((left_bank > bottom) & (!is.na(left_bank))) & ((right_bank > bottom) & (!is.na(right_bank))) ~ TRUE,
#         # left_bank > bottom & right_bank > bottom ~ TRUE,
#         TRUE                                     ~ FALSE
#       ),
#       correct_valid_banks = valid_banks == double_check_valid_banks
#     ) %>% 
#     dplyr::relocate(correct_valid_banks, double_check_valid_banks, valid_banks) 
#   
#   all_valid_banks_are_correct <- all(true_valid_banks$correct_valid_banks)
#   testthat::expect_true(all_valid_banks_are_correct)
#   
# })
# 
# 
# # TODO: Left off here on 2024-08-27
# # TODO: IDEAL SHAPE ("left_bank", "right_bank", "bottom", "channel" point types) 
# #  \              /
# #   \            /
# #    __       __
# #      \     /
# #       \   /
# #        __
# testthat::test_that("'classify_points' - (1 cross section, VALID (relief=T, banks=T)) - left_bank above bottm, flat left channel, flat bottom, flat right channel, and right_bank above bottom", {
#   ID_COL <- "hy_id"
#   
#   cs <-
#     data.frame(
#       hy_id      = c("A", "A", "A", "A", "A", "A", "A", "A", "A", "A"),
#       cs_id      = c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1),
#       pt_id             = c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10),
#       cs_lengthm        = c(100, 100, 100, 100, 100, 100, 100, 100, 100, 100),
#       relative_distance = c(0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9),
#       # point_type = c('left_bank', 'left_bank', 'channel', 'channel', 'bottom', 'bottom', 'channel', 'channel', 'right_bank', 'right_bank'),
#       Z          = c(9, 7, 5, 5, 2, 2, 5, 5, 7, 9)
#     )
#   
#   # plot(cs$Z~cs$pt_id)
#   
#   cpts <- classify_points(cs, crosswalk_id = ID_COL)
#   
#   # classify_points(ideal_pts, crosswalk_id = ID_COL) %>% 
#   #   plot_cs_pts(color = "point_type", size = 4)
#   
#   expected_point_types <- c('left_bank', 'channel', 'channel', 'channel', 
#                             'bottom', 'bottom', 
#                             'channel', 'channel', 'channel', 'right_bank')
#   
#   testthat::expect_true(
#     all(cpts$point_type == expected_point_types)
#   )
# })
# 
# # TODO: Left off here on 2024-08-27
# # TODO: IDEAL SHAPE ("left_bank", "right_bank", "bottom", "channel" point types) 
# #   \     /
# #    \   /
# #      _
# testthat::test_that("'classify_points' - (1 cross section, 3 pts, VALID (relief=T, banks=T)) - 3 point 'V' shaped cross section", {
#   
#   ID_COL            <- "hy_id"
#   
#   # cs <- generate_cs(
#   #   num_unique_ids = 1,
#   #   num_pts_per_id = 3,
#   #   cs_id          = 1,
#   #   cs_lengthm     = 100,
#   #   num_peaks      = 1,
#   #   amplitude      = 2
#   # )
#   # 
#   # plot(cs$Z)
#   # cpts <- classify_points(cs, crosswalk_id = ID_COL)
#   # cpts %>% hydrofabric3D::plot_cs_pts(color = "point_type")
#   cs <- data.frame(
#     hy_id      = c("A", "A",  "A"),
#     cs_id      = c(1, 1, 1),
#     pt_id             = c(1, 2, 3),
#     cs_lengthm        = c(100, 100, 100),
#     relative_distance = c(0.333333, 0.666667, 1.0000000),
#     Z = c(4, 1, 4)
#   )
#   
#   cpts <- classify_points(cs, crosswalk_id = ID_COL)
#   
#   expected_point_types <- c("left_bank", "bottom", "right_bank")
#   
#   # correct point types
#   testthat::expect_true(
#     all(cpts$point_type == expected_point_types)
#   )
#   
#   # correct has relief
#   testthat::expect_true(
#     all(cpts$has_relief)
#   )
#   
#   # correct valid_banks
#   testthat::expect_true(
#     all(cpts$valid_banks)
#   )
#   
# })
# 
# # TODO: Left off here on 2024-08-27
# # TODO: IDEAL SHAPE ("left_bank", "right_bank", "bottom", "channel" point types) 
# #   \     /
# #    \   /
# #      _
# testthat::test_that("'classify_points' - (1 cross section, 5 pts, 'V' shape, VALID (relief=T, banks=T)) - 1 LB -> 1 CHAN -> 1 BOTTOM -> 1 CHAN -> 1 RB", {
#   
#   ID_COL            <- "hy_id"
#   
#   cs <- data.frame(
#     hy_id      = c("A", "A",  "A", "A", "A"),
#     cs_id      = c(1, 1, 1, 1, 1),
#     pt_id             = c(1, 2, 3, 4, 5),
#     cs_lengthm        = c(100, 100, 100, 100, 100),
#     relative_distance = c(0.2, 0.4, 0.6, 0.8, 1.0),
#     # relative_distance = c(0.333333, 0.666667, 1.0000000),
#     Z = c(4, 3, 1, 3, 4)
#   )
#   cpts <- classify_points(cs, crosswalk_id = ID_COL)
#   
#   # cpts$Z %>% plot()
#   # cpts$point_type
#   
#   expected_point_types <- c("left_bank", "channel", "bottom", "channel", "right_bank")
#   
#   # correct point types
#   testthat::expect_true(
#     all(cpts$point_type == expected_point_types)
#   )
#   
#   # correct left bank value
#   testthat::expect_true(
#     all(cpts$left_bank == 4)
#   )
#   
#   # correct right bank value
#   testthat::expect_true(
#     all(cpts$right_bank == 4)
#   )
#   
#   # correct bottom value
#   testthat::expect_true(
#     all(cpts$bottom == 1)
#   )
#   
#   # correct has relief
#   testthat::expect_true(
#     all(cpts$has_relief)
#   )
#   
#   # correct valid_banks
#   testthat::expect_true(
#     all(cpts$valid_banks)
#   )
#   
# })
# 
# # TODO: IDEAL SHAPE ("left_bank", "right_bank", "bottom", "channel" point types) 
# #   \      /
# #    \    /
# #      __
# testthat::test_that("'classify_points' - (1 cross section, 6 pts, 'V' shape, VALID (relief=T, banks=T)) - 1 LB -> 1 CHAN -> 2 BOTTOM -> 1 CHAN -> 1 RB", {
#   
#   ID_COL            <- "hy_id"
#   NUM_CS_PTS   <- 6
#   CS_LENGTH    <- 100
#   REL_DIST     <- seq(0, 1, length.out=NUM_CS_PTS+1)[2:(NUM_CS_PTS+1)]
#   Z_VALS       <- c(4, 3, 1, 1, 3, 4) 
#   
#   cs <- data.frame(
#     hy_id             = rep("A", NUM_CS_PTS),
#     cs_id             = rep(1, NUM_CS_PTS),
#     pt_id             = 1:NUM_CS_PTS,
#     cs_lengthm        = rep(CS_LENGTH, NUM_CS_PTS),
#     relative_distance = REL_DIST,
#     Z                 = Z_VALS
#   )
#   
#   cpts <- classify_points(cs, crosswalk_id = ID_COL)
#   
#   # cpts$point_type
#   # cpts$Z %>% plot()
#   # Z_VALS %>% plot()
#   
#   expected_point_types <- c("left_bank", "channel", "bottom", "channel", "channel", "right_bank")
#   
#   # correct point types
#   testthat::expect_true(
#     all(cpts$point_type == expected_point_types)
#   )
#   
#   # correct left bank value
#   testthat::expect_true(
#     all(cpts$left_bank == 4)
#   )
#   
#   # correct right bank value
#   testthat::expect_true(
#     all(cpts$right_bank == 4)
#   )
#   
#   # correct bottom value
#   testthat::expect_true(
#     all(cpts$bottom == 1)
#   )
#   
#   # correct has relief
#   testthat::expect_true(
#     all(cpts$has_relief)
#   )
#   
#   # correct valid_banks
#   testthat::expect_true(
#     all(cpts$valid_banks)
#   )
#   
# })
# 
# 
# # TODO: IDEAL SHAPE ("left_bank", "right_bank", "bottom", "channel" point types) 
# #   \       /
# #    \     /
# #      ___
# testthat::test_that("'classify_points' - (1 cross section, 7 pts, 'V' shape, VALID (relief=T, banks=T)) - 1 LB -> 1 CHAN -> 3 BOTTOM -> 1 CHAN -> 1 RB", {
#   
#   ID_COL       <- "hy_id"
#   NUM_CS_PTS   <- 7
#   CS_LENGTH    <- 100
#   REL_DIST     <- seq(0, 1, length.out=NUM_CS_PTS+1)[2:(NUM_CS_PTS+1)]
#   Z_VALS       <- c(4, 3, 1, 1, 1, 3, 4) 
#   
#   cs <- data.frame(
#     hy_id             = rep("A", NUM_CS_PTS),
#     cs_id             = rep(1, NUM_CS_PTS),
#     pt_id             = 1:NUM_CS_PTS,
#     cs_lengthm        = rep(CS_LENGTH, NUM_CS_PTS),
#     relative_distance = REL_DIST,
#     Z                 = Z_VALS
#   )
#   
#   cpts <- classify_points(cs, crosswalk_id = ID_COL)
#   
#   # cpts$point_type
#   # cpts$Z %>% plot()
#   # Z_VALS %>% plot()
#   
#   expected_point_types <- c("left_bank", "channel", "bottom", "bottom", "bottom", "channel", "right_bank")
#   
#   # correct point types
#   testthat::expect_true(
#     all(cpts$point_type == expected_point_types)
#   )
#   
#   # correct left bank value
#   testthat::expect_true(
#     all(cpts$left_bank == 4)
#   )
#   
#   # correct right bank value
#   testthat::expect_true(
#     all(cpts$right_bank == 4)
#   )
#   
#   # correct bottom value
#   testthat::expect_true(
#     all(cpts$bottom == 1)
#   )
#   
#   # correct has relief
#   testthat::expect_true(
#     all(cpts$has_relief)
#   )
#   
#   # correct valid_banks
#   testthat::expect_true(
#     all(cpts$valid_banks)
#   )
#   
# })
# 
# # TODO: IDEAL SHAPE ("left_bank", "right_bank", "bottom", "channel" point types) 
# #   \       /
# #    \     /
# #      ___
# testthat::test_that("'classify_points' - (1 cross section, 8 pts, 'V' shape, VALID (relief=T, banks=T)) - 1 LB -> 1 CHAN -> 4 BOTTOM -> 1 CHAN -> 1 RB", {
#   
#   ID_COL       <- "hy_id"
#   NUM_CS_PTS   <- 8
#   CS_LENGTH    <- 100
#   REL_DIST     <- seq(0, 1, length.out=NUM_CS_PTS+1)[2:(NUM_CS_PTS+1)]
#   Z_VALS       <- c(4, 3, 1, 1, 1, 1, 3, 4) 
#   
#   cs <- data.frame(
#     hy_id             = rep("A", NUM_CS_PTS),
#     cs_id             = rep(1, NUM_CS_PTS),
#     pt_id             = 1:NUM_CS_PTS,
#     cs_lengthm        = rep(CS_LENGTH, NUM_CS_PTS),
#     relative_distance = REL_DIST,
#     Z                 = Z_VALS
#   )
#   
#   cpts <- classify_points(cs, crosswalk_id = ID_COL)
#   # cpts <- classify_points(cs, crosswalk_id = ID_COL)
#   Z_VALS %>% plot()
#   cpts$Z %>% plot()
#   cpts$point_type
#   
#   expected_point_types <- c("left_bank", "channel", "bottom", "bottom", "bottom", "channel", "channel", "right_bank")
#   
#   # correct point types
#   testthat::expect_true(
#     all(cpts$point_type == expected_point_types)
#   )
#   
#   # correct left bank value
#   testthat::expect_true(
#     all(cpts$left_bank == 4)
#   )
#   
#   # correct right bank value
#   testthat::expect_true(
#     all(cpts$right_bank == 4)
#   )
#   
#   # correct bottom value
#   testthat::expect_true(
#     all(cpts$bottom == 1)
#   )
#   
#   # correct has relief
#   testthat::expect_true(
#     all(cpts$has_relief)
#   )
#   
#   # correct valid_banks
#   testthat::expect_true(
#     all(cpts$valid_banks)
#   )
#   
# })
# 
# 
# # generate_cs <- function(num_unique_ids = 1, 
# #                                num_pts_per_id = 3, 
# #                                cs_id = 1, 
# #                                cs_lengthm = 100,
# #                                num_peaks = 1, 
# #                                amplitude = 1
# #                                ) {
# #   unique_ids <- LETTERS[1:num_unique_ids]
# #   rel_dist_interval <- (cs_lengthm / num_pts_per_id) / 100
# #   rel_dist <- cumsum(rep(rel_dist_interval, num_pts_per_id))
# #   
# #   # Generate Z values based on sine wave to simulate peaks and troughs, shifted upwards to be > 0
# #   x <- seq(0, 2 * pi * num_peaks, length.out = num_pts_per_id)
# #   z_values <- amplitude * sin(x) + amplitude
# #   
# #   cs <- data.frame(
# #     hy_id = rep(unique_ids, each = num_pts_per_id),
# #     cs_id = rep(cs_id, num_unique_ids * num_pts_per_id),
# #     pt_id = rep(1:num_pts_per_id, times = num_unique_ids),
# #     cs_lengthm = rep(cs_lengthm, num_unique_ids * num_pts_per_id),
# #     relative_distance = rel_dist,
# #     Z = rep(z_values, times = num_unique_ids)
# #   )
# #   return(cs)
# # }
# # 
# # classify_z_pts <- function(Z) {
# #   slope          <- diff(c(0, Z))  
# #   bottomZ        <- min(Z)      
# #   points_per_id  <- length(Z)
# #   
# #   classification <- sapply(1:points_per_id, function(i) {
# #     message(i)
# #     if (i == 1) {
# #       message("LB\n")
# #       return("left_bank")   # handle first point
# #     } else if (i == points_per_id) {
# #       message("RB\n")
# #       return("right_bank")  # and the last point
# #     } else if (Z[i] == bottomZ) {
# #       message("BOTTOM\n")
# #       return("bottom")      # identify the bottom point(s) (min Z value)
# #     } else if (slope[i] > 0) {
# #       if (slope[i + 1] <= 0) {
# #         message("CHAN\n")
# #         return("channel")     #  slope changing from rising to falling (approaching bottom)
# #       } else {
# #         message("RB\n")
# #         return("right_bank")  # rising slope but not near the bottom
# #       }
# #     } else if (slope[i] < 0) {
# #       if (slope[i - 1] >= 0 || slope[i + 1] == 0) {
# #         message("CHAN\n")
# #         return("channel")   # slope changing from falling to rising (leaving bottom)
# #       } else {
# #       message("LB\n")
# #       return("left_bank")  #  slope  falling but not near the bottom
# #       }
# #     } else if(slope[i] == 0) {
# #       message("SLOPE is 0 --> CHAN\n")
# #       return("channel")
# #     }
# #     
# #     message("NO MATCH\n")
# #     
# #   })
# #   
# #   return(classification)
# # }
# 
# 
# 
# # TODO: IDEAL SHAPE ("left_bank", "right_bank", "bottom", "channel" point types) 
# #   \       /
# #    \     /
# #      ___
# testthat::test_that("'classify_points' - (1 cross section, 9 pts, 'V' shape, VALID (relief=T, banks=T)) - 1 LB -> 1 CHAN -> 5 BOTTOM -> 1 CHAN -> 1 RB", {
#   
#   ID_COL       <- "hy_id"
#   NUM_CS_PTS   <- 9
#   CS_LENGTH    <- 100
#   REL_DIST     <- seq(0, 1, length.out=NUM_CS_PTS+1)[2:(NUM_CS_PTS+1)]
#   Z_VALS       <- c(4, 3, 1, 1, 1, 1, 1, 3, 4) 
#   
#   cs <- data.frame(
#     hy_id             = rep("A", NUM_CS_PTS),
#     cs_id             = rep(1, NUM_CS_PTS),
#     pt_id             = 1:NUM_CS_PTS,
#     cs_lengthm        = rep(CS_LENGTH, NUM_CS_PTS),
#     relative_distance = REL_DIST,
#     Z                 = Z_VALS
#   )
#   
#   cpts <- classify_points(cs, crosswalk_id = ID_COL)
#   # cpts <- classify_points(cs, crosswalk_id = ID_COL)
#   
#   # Z_VALS %>% plot()
#   # cpts$Z %>% plot()
#   # cpts$point_type
#   
#   expected_point_types <- c("left_bank", "channel", "bottom", "bottom", "bottom", "channel", "channel", "channel", "right_bank")
#   
#   # correct point types
#   testthat::expect_true(
#     all(cpts$point_type == expected_point_types)
#   )
#   
#   # correct left bank value
#   testthat::expect_true(
#     all(cpts$left_bank == 4)
#   )
#   
#   # correct right bank value
#   testthat::expect_true(
#     all(cpts$right_bank == 4)
#   )
#   
#   # correct bottom value
#   testthat::expect_true(
#     all(cpts$bottom == 1)
#   )
#   
#   # correct has relief
#   testthat::expect_true(
#     all(cpts$has_relief)
#   )
#   
#   # correct valid_banks
#   testthat::expect_true(
#     all(cpts$valid_banks)
#   )
#   
# })
# 
# 
# # TODO: IDEAL SHAPE ("left_bank", "right_bank", "bottom", "channel" point types) 
# # NOTE: Cross section shape:
# #   \        /
# #    \      /
# #      ____
# testthat::test_that("'classify_points' - (1 cross section, 10 pts, 'V' shape, VALID (relief=T, banks=T)) - 1 LB -> 1 CHAN -> 6 BOTTOM -> 1 CHAN -> 1 RB", {
#   
#   ID_COL       <- "hy_id"
#   NUM_CS_PTS   <- 10
#   CS_LENGTH    <- 100
#   REL_DIST     <- seq(0, 1, length.out=NUM_CS_PTS+1)[2:(NUM_CS_PTS+1)]
#   Z_VALS       <- c(4, 3, 1, 1, 1, 1, 1, 1, 3, 4) 
#   
#   cs <- data.frame(
#     hy_id             = rep("A", NUM_CS_PTS),
#     cs_id             = rep(1, NUM_CS_PTS),
#     pt_id             = 1:NUM_CS_PTS,
#     cs_lengthm        = rep(CS_LENGTH, NUM_CS_PTS),
#     relative_distance = REL_DIST,
#     Z                 = Z_VALS
#   )
#   
#   cpts <- classify_points(cs, crosswalk_id = ID_COL)
#   # cpts <- classify_points(cs, crosswalk_id = ID_COL)
#   
#   # Z_VALS %>% plot()
#   # cpts$Z %>% plot()
#   # cpts$point_type
#   
#   expected_point_types <- c("left_bank", "channel", "channel", "bottom", "bottom", "bottom", "bottom", "channel", "channel", "right_bank")
#   
#   # correct point types
#   testthat::expect_true(
#     all(cpts$point_type == expected_point_types)
#   )
#   
#   # correct left bank value
#   testthat::expect_true(
#     all(cpts$left_bank == 4)
#   )
#   
#   # correct right bank value
#   testthat::expect_true(
#     all(cpts$right_bank == 4)
#   )
#   
#   # correct bottom value
#   testthat::expect_true(
#     all(cpts$bottom == 1)
#   )
#   
#   # correct has relief
#   testthat::expect_true(
#     all(cpts$has_relief)
#   )
#   
#   # correct valid_banks
#   testthat::expect_true(
#     all(cpts$valid_banks)
#   )
#   
# })
# 
# 
# # TODO: IDEAL SHAPE ("left_bank", "right_bank", "bottom", "channel" point types) 
# # NOTE: Cross section shape:
# #   \        /
# #    \      /
# #      ____
# testthat::test_that("'classify_points' - (1 cross section, 10 pts, 'V' shape, VALID (relief=T, banks=T)) - 1 LB -> 1 CHAN -> 6 BOTTOM -> 1 CHAN -> 1 RB", {
#   
#   ID_COL       <- "hy_id"
#   NUM_CS_PTS   <- 10
#   CS_LENGTH    <- 100
#   REL_DIST     <- seq(0, 1, length.out=NUM_CS_PTS+1)[2:(NUM_CS_PTS+1)]
#   Z_VALS       <- c(4, 3, 1, 1, 1, 1, 1, 1, 3, 4) 
#   
#   cs <- data.frame(
#     hy_id             = rep("A", NUM_CS_PTS),
#     cs_id             = rep(1, NUM_CS_PTS),
#     pt_id             = 1:NUM_CS_PTS,
#     cs_lengthm        = rep(CS_LENGTH, NUM_CS_PTS),
#     relative_distance = REL_DIST,
#     Z                 = Z_VALS
#   )
#   
#   cpts <- classify_points(cs, crosswalk_id = ID_COL)
#   # cpts <- classify_points(cs, crosswalk_id = ID_COL)
#   
#   # Z_VALS %>% plot()
#   # cpts$Z %>% plot()
#   # cpts$point_type
#   
#   expected_point_types <- c("left_bank", "channel", "channel", "bottom", "bottom", "bottom", "bottom", "channel", "channel", "right_bank")
#   
#   # correct point types
#   testthat::expect_true(
#     all(cpts$point_type == expected_point_types)
#   )
#   
#   # correct left bank value
#   testthat::expect_true(
#     all(cpts$left_bank == 4)
#   )
#   
#   # correct right bank value
#   testthat::expect_true(
#     all(cpts$right_bank == 4)
#   )
#   
#   # correct bottom value
#   testthat::expect_true(
#     all(cpts$bottom == 1)
#   )
#   
#   # correct has relief
#   testthat::expect_true(
#     all(cpts$has_relief)
#   )
#   
#   # correct valid_banks
#   testthat::expect_true(
#     all(cpts$valid_banks)
#   )
#   
# })
# 
# # TODO: Really wide IDEAL / VALID (relief=T, banks=T) shape with single bank points
# # NOTE: Cross section shape:
# #   \_______________/
# testthat::test_that("'classify_points' - (1 cross section, 10 pts, 'WIDE U' shape, VALID (relief=T, banks=T)) - 1 LB -> 2 CHAN -> 4 BOTTOM -> 2 CHAN -> 1 RB", {
#   
#   ID_COL       <- "hy_id"
#   NUM_CS_PTS   <- 10
#   CS_LENGTH    <- 100
#   REL_DIST     <- seq(0, 1, length.out=NUM_CS_PTS+1)[2:(NUM_CS_PTS+1)]
#   Z_VALS       <- c(3, 1, 1, 1, 1, 1, 1, 1, 1, 3) 
#   
#   cs <- data.frame(
#     hy_id             = rep("A", NUM_CS_PTS),
#     cs_id             = rep(1, NUM_CS_PTS),
#     pt_id             = 1:NUM_CS_PTS,
#     cs_lengthm        = rep(CS_LENGTH, NUM_CS_PTS),
#     relative_distance = REL_DIST,
#     Z                 = Z_VALS
#   )
#   
#   cpts <- classify_points(cs, crosswalk_id = ID_COL)
#   # cpts <- classify_points(cs, crosswalk_id = ID_COL)
#   
#   # Z_VALS %>% plot()
#   # cpts$Z %>% plot()
#   # cpts$point_type
#   
#   expected_point_types <- c("left_bank", "channel", "channel", 
#                             "bottom", "bottom", "bottom", "bottom", 
#                             "channel", "channel", "right_bank")
#   
#   # correct point types
#   testthat::expect_true(
#     all(cpts$point_type == expected_point_types)
#   )
#   
#   # correct left bank value
#   testthat::expect_true(
#     all(cpts$left_bank == 3)
#   )
#   
#   # correct right bank value
#   testthat::expect_true(
#     all(cpts$right_bank == 3)
#   )
#   
#   # correct bottom value
#   testthat::expect_true(
#     all(cpts$bottom == 1)
#   )
#   
#   # correct has relief
#   testthat::expect_true(
#     all(cpts$has_relief)
#   )
#   
#   # correct valid_banks
#   testthat::expect_true(
#     all(cpts$valid_banks)
#   )
#   
# })
# 
# # TODO: Really wide IDEAL / VALID (relief=T, banks=T) shape with single LEFT BANK point and higher RIGHT BANK
# # NOTE: Cross section shape:
# #                       /
# #                     /
# #   \_______________/
# testthat::test_that("'classify_points' - (1 cross section, 10 pts, 'WIDE U, HIGH RB' shape, VALID (relief=T, banks=T)) - 1 LB -> 2 CHAN -> 4 BOTTOM -> 2 CHAN -> 1 RB", {
#   
#   ID_COL       <- "hy_id"
#   NUM_CS_PTS   <- 10
#   CS_LENGTH    <- 100
#   REL_DIST     <- seq(0, 1, length.out=NUM_CS_PTS+1)[2:(NUM_CS_PTS+1)]
#   Z_VALS       <- c(3, 1, 1, 1, 1, 1, 1, 2, 3, 5) 
#   
#   cs <- data.frame(
#     hy_id             = rep("A", NUM_CS_PTS),
#     cs_id             = rep(1, NUM_CS_PTS),
#     pt_id             = 1:NUM_CS_PTS,
#     cs_lengthm        = rep(CS_LENGTH, NUM_CS_PTS),
#     relative_distance = REL_DIST,
#     Z                 = Z_VALS
#   )
#   
#   cpts <- classify_points(cs, crosswalk_id = ID_COL)
#   # cpts <- classify_points(cs, crosswalk_id = ID_COL)
#   
#   Z_VALS %>% plot()
#   cpts$Z %>% plot()
#   cpts$point_type
#   
#   expected_point_types <- c("left_bank", "channel", "channel", 
#                             "bottom", "bottom", "bottom", "bottom", 
#                             "channel", "channel", "right_bank")
#   
#   # correct point types
#   testthat::expect_true(
#     all(cpts$point_type == expected_point_types)
#   )
#   
#   # correct left bank value
#   testthat::expect_true(
#     all(cpts$left_bank == 3)
#   )
#   
#   # correct right bank value
#   testthat::expect_true(
#     all(cpts$right_bank == 5)
#   )
#   
#   # correct bottom value
#   testthat::expect_true(
#     all(cpts$bottom == 1)
#   )
#   
#   # correct has relief
#   testthat::expect_true(
#     all(cpts$has_relief)
#   )
#   
#   # correct valid_banks
#   testthat::expect_true(
#     all(cpts$valid_banks)
#   )
#   
# })
# 
# # TODO: Really wide IDEAL / VALID (relief=T, banks=T) shape with single RIGHT BANK points and higher LEFT BANK
# # NOTE: Cross section shape:
# #  \                     
# #   \                  
# #    \_______________/
# testthat::test_that("'classify_points' - (1 cross section, 10 pts, 'WIDE U, HIGH LB' shape, VALID (relief=T, banks=T)) - 1 LB -> 2 CHAN -> 4 BOTTOM -> 2 CHAN -> 1 RB", {
#   
#   ID_COL       <- "hy_id"
#   NUM_CS_PTS   <- 10
#   CS_LENGTH    <- 100
#   REL_DIST     <- seq(0, 1, length.out=NUM_CS_PTS+1)[2:(NUM_CS_PTS+1)]
#   Z_VALS       <- c(5, 3, 2, 1, 1, 1, 1, 1, 1, 3) 
#   
#   cs <- data.frame(
#     hy_id             = rep("A", NUM_CS_PTS),
#     cs_id             = rep(1, NUM_CS_PTS),
#     pt_id             = 1:NUM_CS_PTS,
#     cs_lengthm        = rep(CS_LENGTH, NUM_CS_PTS),
#     relative_distance = REL_DIST,
#     Z                 = Z_VALS
#   )
#   
#   cpts <- classify_points(cs, crosswalk_id = ID_COL)
#   # cpts <- classify_points(cs, crosswalk_id = ID_COL)
#   
#   Z_VALS %>% plot()
#   cpts$Z %>% plot()
#   cpts$point_type
#   
#   expected_point_types <- c("left_bank", "channel", "channel", 
#                             "bottom", "bottom", "bottom", "bottom", 
#                             "channel", "channel", "right_bank")
#   
#   # correct point types
#   testthat::expect_true(
#     all(cpts$point_type == expected_point_types)
#   )
#   
#   # correct left bank value
#   testthat::expect_true(
#     all(cpts$left_bank == 5)
#   )
#   
#   # correct right bank value
#   testthat::expect_true(
#     all(cpts$right_bank == 3)
#   )
#   
#   # correct bottom value
#   testthat::expect_true(
#     all(cpts$bottom == 1)
#   )
#   
#   # correct has relief
#   testthat::expect_true(
#     all(cpts$has_relief)
#   )
#   
#   # correct valid_banks
#   testthat::expect_true(
#     all(cpts$valid_banks)
#   )
#   
# })
# 
# # TODO: IDEAL SHAPE with LIP ("left_bank", "right_bank", "bottom", "channel" point types) 
# # NOTE: Cross section shape:
# # __           __
# #   \        /
# #    \      /
# #      ____
# testthat::test_that("'classify_points' - (1 cross section, 10 pts, 'V + lips' shape, VALID (relief=T, banks=T)) - 2 LB -> 2 CHAN -> 2 BOTTOM -> 3 CHAN -> 1 RB", {
#   
#   ID_COL       <- "hy_id"
#   
#   # cs <- make_cs(
#   #   left_bank = c(4, 4, 2),
#   #   left_channel = c(4, 1, 3),
#   #   bottom = c(1, 1, 4),
#   #   right_bank = c(1, 4, 3)
#   # ) 
#   # 
#   # cs[[ID_COL]]   <- "A"
#   # cs$cs_id       <- 1
#   # cs$cs_lengthm  <- 100
#   # cs$Z %>% plot()
#   # make_cs_curve(left_y_range = c()
#   
#   NUM_CS_PTS   <- 10
#   CS_LENGTH    <- 100
#   REL_DIST     <- seq(0, 1, length.out=NUM_CS_PTS+1)[2:(NUM_CS_PTS+1)]
#   Z_VALS       <- c(4, 4, 4, 3, 1, 1, 3, 4, 4, 4)
#   Z_VALS %>% plot()
#   cs <- data.frame(
#     hy_id             = rep("A", NUM_CS_PTS),
#     cs_id             = rep(1, NUM_CS_PTS),
#     pt_id             = 1:NUM_CS_PTS,
#     cs_lengthm        = rep(CS_LENGTH, NUM_CS_PTS),
#     relative_distance = REL_DIST,
#     Z                 = Z_VALS
#   )
#   
#   cpts <- classify_points(cs, crosswalk_id = ID_COL)
#   # cpts <- classify_points(cs, crosswalk_id = ID_COL)
#   
#   # Z_VALS %>% plot()
#   # cpts$Z %>% plot()
#   # cpts$point_type
#   
#   expected_point_types <- c("left_bank", "left_bank", "channel", "channel", 
#                             "bottom", "bottom", "channel", 
#                             "channel", "channel", "right_bank")
#   
#   # correct point types
#   testthat::expect_true(
#     all(cpts$point_type == expected_point_types)
#   )
#   
#   # correct left bank value
#   testthat::expect_true(
#     all(cpts$left_bank == 4)
#   )
#   
#   # correct right bank value
#   testthat::expect_true(
#     all(cpts$right_bank == 4)
#   )
#   
#   # correct bottom value
#   testthat::expect_true(
#     all(cpts$bottom == 1)
#   )
#   
#   # correct has relief
#   testthat::expect_true(
#     all(cpts$has_relief)
#   )
#   
#   # correct valid_banks
#   testthat::expect_true(
#     all(cpts$valid_banks)
#   )
#   
# })
# 
# # TODO: IDEAL SHAPE with a break in BOTH channels, where it flattens out
# # NOTE: Cross section shape:
# # \                   /
# #   --             --
# #      \         /
# #       \      /
# #         ____
# testthat::test_that("'classify_points' - (1 cross section, 10 pts, 'V + breaks in both channel' shape, VALID (relief=T, banks=T)) - 1 LB -> 3 CHAN -> 2 BOTTOM -> 3 CHAN -> 1 RB", {
#   
#   ID_COL       <- "hy_id"
#   NUM_CS_PTS   <- 10
#   CS_LENGTH    <- 100
#   REL_DIST     <- seq(0, 1, length.out=NUM_CS_PTS+1)[2:(NUM_CS_PTS+1)]
#   Z_VALS       <- c(6, 4, 4, 3, 1, 1, 3, 4, 4, 6)
#   # Z_VALS %>% plot()
#   
#   cs <- data.frame(
#     hy_id             = rep("A", NUM_CS_PTS),
#     cs_id             = rep(1, NUM_CS_PTS),
#     pt_id             = 1:NUM_CS_PTS,
#     cs_lengthm        = rep(CS_LENGTH, NUM_CS_PTS),
#     relative_distance = REL_DIST,
#     Z                 = Z_VALS
#   )
#   
#   cpts <- classify_points(cs, crosswalk_id = ID_COL)
#   # cpts <- classify_points(cs, crosswalk_id = ID_COL)
#   
#   # Z_VALS %>% plot()
#   # cpts$Z %>% plot()
#   # cpts$point_type
#   
#   expected_point_types <- c("left_bank", "channel", "channel", "channel", 
#                             "bottom", "bottom", "channel", 
#                             "channel", "channel", "right_bank")
#   
#   # correct point types
#   testthat::expect_true(
#     all(cpts$point_type == expected_point_types)
#   )
#   
#   # correct left bank value
#   testthat::expect_true(
#     all(cpts$left_bank == 6)
#   )
#   
#   # correct right bank value
#   testthat::expect_true(
#     all(cpts$right_bank == 6)
#   )
#   
#   # correct bottom value
#   testthat::expect_true(
#     all(cpts$bottom == 1)
#   )
#   
#   # correct has relief
#   testthat::expect_true(
#     all(cpts$has_relief)
#   )
#   
#   # correct valid_banks
#   testthat::expect_true(
#     all(cpts$valid_banks)
#   )
#   
# })
# 
# # TODO: IDEAL SHAPE with a break in only LEFT side of channel, where it flattens out for a bit
# # NOTE: Cross section shape:
# # \                  /
# #   --             /
# #      \         /
# #       \      /
# #         ____
# testthat::test_that("'classify_points' - (1 cross section, 10 pts, 'V + breaks in LEFT side of channel' shape, VALID (relief=T, banks=T)) - 1 LB -> 1 CHAN -> 6 BOTTOM -> 1 CHAN -> 1 RB", {
#   
#   ID_COL       <- "hy_id"
#   NUM_CS_PTS   <- 10
#   CS_LENGTH    <- 100
#   REL_DIST     <- seq(0, 1, length.out=NUM_CS_PTS+1)[2:(NUM_CS_PTS+1)]
#   Z_VALS       <- c(6, 4, 4, 3, 1, 1, 3, 4, 5, 6)
#   
#   cs <- data.frame(
#     hy_id             = rep("A", NUM_CS_PTS),
#     cs_id             = rep(1, NUM_CS_PTS),
#     pt_id             = 1:NUM_CS_PTS,
#     cs_lengthm        = rep(CS_LENGTH, NUM_CS_PTS),
#     relative_distance = REL_DIST,
#     Z                 = Z_VALS
#   )
#   
#   cpts <- classify_points(cs, crosswalk_id = ID_COL)
#   # cpts <- classify_points(cs, crosswalk_id = ID_COL)
#   
#   # Z_VALS %>% plot()
#   # cpts$Z %>% plot()
#   # cpts$point_type
#   
#   expected_point_types <- c("left_bank", "channel", "channel", "channel", 
#                             "bottom", "bottom", "channel", 
#                             "channel", "channel", "right_bank")
#   
#   # correct point types
#   testthat::expect_true(
#     all(cpts$point_type == expected_point_types)
#   )
#   
#   # correct left bank value
#   testthat::expect_true(
#     all(cpts$left_bank == 6)
#   )
#   
#   # correct right bank value
#   testthat::expect_true(
#     all(cpts$right_bank == 6)
#   )
#   
#   # correct bottom value
#   testthat::expect_true(
#     all(cpts$bottom == 1)
#   )
#   
#   # correct has relief
#   testthat::expect_true(
#     all(cpts$has_relief)
#   )
#   
#   # correct valid_banks
#   testthat::expect_true(
#     all(cpts$valid_banks)
#   )
#   
# })
# # TODO: IDEAL SHAPE with a break in only RIGHT side of channel, where it flattens out for a bit
# # NOTE: Cross section shape:
# #    \                  /
# #     \             --
# #      \         /
# #       \      /
# #         ____
# testthat::test_that("'classify_points' - (1 cross section, 10 pts, 'V + breaks in RIGHT side of channel' shape, VALID (relief=T, banks=T)) - 1 LB -> 1 CHAN -> 6 BOTTOM -> 1 CHAN -> 1 RB", {
#   
#   ID_COL       <- "hy_id"
#   NUM_CS_PTS   <- 10
#   CS_LENGTH    <- 100
#   REL_DIST     <- seq(0, 1, length.out=NUM_CS_PTS+1)[2:(NUM_CS_PTS+1)]
#   Z_VALS       <- c(6, 5, 4, 3, 1, 1, 3, 4, 4, 6)
#   
#   cs <- data.frame(
#     hy_id             = rep("A", NUM_CS_PTS),
#     cs_id             = rep(1, NUM_CS_PTS),
#     pt_id             = 1:NUM_CS_PTS,
#     cs_lengthm        = rep(CS_LENGTH, NUM_CS_PTS),
#     relative_distance = REL_DIST,
#     Z                 = Z_VALS
#   )
#   
#   cpts <- classify_points(cs, crosswalk_id = ID_COL)
#   # cpts <- classify_points(cs, crosswalk_id = ID_COL)
#   
#   # Z_VALS %>% plot()
#   # cpts$Z %>% plot()
#   # cpts$point_type
#   
#   expected_point_types <- c("left_bank", "channel", "channel", "channel", 
#                             "bottom", "bottom", "channel", 
#                             "channel", "channel", "right_bank")
#   
#   # correct point types
#   testthat::expect_true(
#     all(cpts$point_type == expected_point_types)
#   )
#   
#   # correct left bank value
#   testthat::expect_true(
#     all(cpts$left_bank == 6)
#   )
#   
#   # correct right bank value
#   testthat::expect_true(
#     all(cpts$right_bank == 6)
#   )
#   
#   # correct bottom value
#   testthat::expect_true(
#     all(cpts$bottom == 1)
#   )
#   
#   # correct has relief
#   testthat::expect_true(
#     all(cpts$has_relief)
#   )
#   
#   # correct valid_banks
#   testthat::expect_true(
#     all(cpts$valid_banks)
#   )
#   
# })
# 
# # TODO: There is a valid bottom here but algorithm struggles to find it because 
# # TODO: the minimum point that is the actual bottom is NOT in the middle third of the cross section
# # NOTE: Cross section shape:
# #                           -----
# #                        /
# #                      /
# #                  ---
# #                / 
# #              /
# #   \        /
# #    \     /
# #      ---
# testthat::test_that("'classify_points' - (1 cross section, 16 pts, 'V on left side' shape, VALID (relief=T, banks=T)) - 1 LB -> 1 CHAN -> 6 BOTTOM -> 1 CHAN -> 1 RB", {
#   
#   ID_COL       <- "hy_id"
#   
#   # cs <- make_cs(
#   #   left_bank = c(4, 4, 2),
#   #   left_channel = c(4, 1, 3),
#   #   bottom = c(1, 1, 4),
#   #   right_bank = c(1, 4, 3)
#   # ) 
#   # 
#   # cs[[ID_COL]]   <- "A"
#   # cs$cs_id       <- 1
#   # cs$cs_lengthm  <- 100
#   # cs$Z %>% plot()
#   # make_cs_curve(left_y_range = c()
#   
#   NUM_CS_PTS   <- 16
#   CS_LENGTH    <- 100
#   REL_DIST     <- seq(0, 1, length.out=NUM_CS_PTS+1)[2:(NUM_CS_PTS+1)]
#   Z_VALS       <- c(6, 5, 3, 2, 3, 4, 5, 6, 7, 8, 8, 8, 9, 9, 9, 9)
#   
#   # Z_VALS %>% plot()
#   cs <- data.frame(
#     hy_id             = rep("A", NUM_CS_PTS),
#     cs_id             = rep(1, NUM_CS_PTS),
#     pt_id             = 1:NUM_CS_PTS,
#     cs_lengthm        = rep(CS_LENGTH, NUM_CS_PTS),
#     relative_distance = REL_DIST,
#     Z                 = Z_VALS
#   )
# 
#   cpts <- classify_points(cs, crosswalk_id = ID_COL)
#   # cpts_rev <- classify_points(cs_rev, crosswalk_id = ID_COL)
#   
#   # cpts$Z %>% plot()
#   # cpts$point_type
#   
#   # Z_VALS %>% plot()
#   # cpts_rev$Z %>% plot()
#   # cpts_rev$point_type
#   
#   expected_point_types <- c("left_bank", "channel", "channel", "channel", "channel",
#                             "bottom", 
#                              "channel", "channel",  "channel", "channel",  
#                             "channel", "channel", "channel", "channel", "right_bank", "right_bank")
# 
#   # correct point types
#   testthat::expect_true(
#     all(cpts$point_type == expected_point_types)
#   )
#   
#   # correct left bank value
#   testthat::expect_true(
#     all(cpts$left_bank == 6)
#   )
#   
#   # correct right bank value
#   testthat::expect_true(
#     all(cpts$right_bank == 9)
#   )
#   
#   # correct bottom value
#   testthat::expect_true(
#     all(cpts$bottom == 4)
#   )
#   
#   # correct has relief
#   testthat::expect_true(
#     all(cpts$has_relief)
#   )
#   
#   # correct valid_banks
#   testthat::expect_true(
#     all(cpts$valid_banks)
#   )
#   
#   # ---- Reverse the cross section shape ----
#   cs_rev <- data.frame(
#     hy_id             = rep("A", NUM_CS_PTS),
#     cs_id             = rep(1, NUM_CS_PTS),
#     pt_id             = 1:NUM_CS_PTS,
#     cs_lengthm        = rep(CS_LENGTH, NUM_CS_PTS),
#     relative_distance = REL_DIST,
#     Z                 = rev(Z_VALS) 
#   )
#   cpts_rev <- classify_points(cs_rev, crosswalk_id = ID_COL)
#   expected_point_types_rev <- c("left_bank", "left_bank", "left_bank", "channel", "channel",
#                             "channel", "channel",  "channel", "channel",  
#                             "channel", "bottom", "channel", "channel", "channel", "channel", "right_bank")
#   # correct point types
#   testthat::expect_true(
#     all(cpts_rev$point_type == expected_point_types_rev)
#   )
#   
#   # correct left bank value
#   testthat::expect_true(
#     all(cpts_rev$left_bank == 9)
#   )
#   
#   # correct right bank value
#   testthat::expect_true(
#     all(cpts_rev$right_bank == 6)
#   )
#   
#   # correct bottom value
#   testthat::expect_true(
#     all(cpts_rev$bottom == 4)
#   )
#   
#   # correct has relief
#   testthat::expect_true(
#     all(cpts_rev$has_relief)
#   )
#   
#   # correct valid_banks
#   testthat::expect_true(
#     all(cpts_rev$valid_banks)
#   )
#   
# })
# 
# # NOTE: Cross section shape:
# #                   /
# #                 /
# #               /
# #         _____
# #       /
# #     /
# #   /
# testthat::test_that("'classify_points' - (1 cross section, 10 pts, INVALID (relief=T, banks=F)) - left_bank below bottom, bottom is flat, and right bank is above bottom", {
#   ID_COL       <- "hy_id"
#   NUM_CS_PTS   <- 10
#   CS_LENGTH    <- 100
#   REL_DIST     <- seq(0, 1, length.out=NUM_CS_PTS+1)[2:(NUM_CS_PTS+1)]
#   Z_VALS       <- c(1, 2, 3, 4, 4, 4, 4, 5, 6, 7) 
#   
#   cs <- data.frame(
#     hy_id             = rep("A", NUM_CS_PTS),
#     cs_id             = rep(1, NUM_CS_PTS),
#     pt_id             = 1:NUM_CS_PTS,
#     cs_lengthm        = rep(CS_LENGTH, NUM_CS_PTS),
#     relative_distance = REL_DIST,
#     Z                 = Z_VALS
#   )
#   
#   cpts <- classify_points(cs, crosswalk_id = ID_COL)
#   # cpts <- classify_points(cs, crosswalk_id = ID_COL)
#   
#   # Z_VALS %>% plot()
#   # cpts$Z %>% plot()
#   # cpts$point_type
#   
#   expected_point_types <- c("left_bank", "left_bank", "channel", 
#                             "bottom", "bottom", "bottom", "bottom", 
#                             "channel", "channel", "right_bank")
#   
#   # correct point types
#   testthat::expect_true(
#     all(cpts$point_type == expected_point_types)
#   )
#   
#   # correct left bank value
#   testthat::expect_true(
#     all(cpts$left_bank == 2)
#   )
#   
#   # correct right bank value
#   testthat::expect_true(
#     all(cpts$right_bank == 7)
#   )
#   
#   # correct bottom value
#   testthat::expect_true(
#     all(cpts$bottom == 4)
#   )
#   
#   # correct has relief (TRUE)
#   testthat::expect_true(
#     all(cpts$has_relief)
#   )
#   
#   # correct valid_banks (FALSE)
#   testthat::expect_false(
#     all(cpts$valid_banks)
#   )
#   
# })
# # NOTE: Cross section shape:
# #     \        
# #      \       
# #       \     
# #        \_____
# #              \
# #               \
# #                \
# testthat::test_that("'classify_points' - (1 cross section, 10 pts, INVALID (relief=T, banks=F)) - left bank ABOVE bottom, bottom is FLAT, and right bank is BELOW bottom", {
#   ID_COL       <- "hy_id"
#   NUM_CS_PTS   <- 10
#   CS_LENGTH    <- 100
#   REL_DIST     <- seq(0, 1, length.out=NUM_CS_PTS+1)[2:(NUM_CS_PTS+1)]
#   Z_VALS       <- c(7, 6, 5, 4, 3, 3, 3, 3, 2, 1) 
#   
#   cs <- data.frame(
#     hy_id             = rep("A", NUM_CS_PTS),
#     cs_id             = rep(1, NUM_CS_PTS),
#     pt_id             = 1:NUM_CS_PTS,
#     cs_lengthm        = rep(CS_LENGTH, NUM_CS_PTS),
#     relative_distance = REL_DIST,
#     Z                 = Z_VALS
#   )
#   
#   cpts <- classify_points(cs, crosswalk_id = ID_COL)
#   # cpts <- classify_points(cs, crosswalk_id = ID_COL)
#   
#   # Z_VALS %>% plot()
#   # cpts$Z %>% plot()
#   # cpts$point_type
#   
#   expected_point_types <- c("left_bank", "channel", "channel", "channel",
#                             "bottom", "bottom", "bottom", "channel", 
#                             "right_bank", "right_bank")
#   
#   # correct point types
#   testthat::expect_true(
#     all(cpts$point_type == expected_point_types)
#   )
#   
#   # correct left bank value
#   testthat::expect_true(
#     all(cpts$left_bank == 7)
#   )
#   
#   # correct right bank value
#   testthat::expect_true(
#     all(cpts$right_bank == 2)
#   )
#   
#   # correct bottom value
#   testthat::expect_true(
#     all(cpts$bottom == 3)
#   )
#   
#   # correct has relief (TRUE)
#   testthat::expect_true(
#     all(cpts$has_relief)
#   )
#   
#   # correct valid_banks (FALSE)
#   testthat::expect_false(
#     all(cpts$valid_banks)
#   )
#   
# })
# 
# # NOTE: Cross section shape:
# #              /
# #            /
# #          /
# #        /
# #      /
# #    /
# #  /
# testthat::test_that("'classify_points' - (1 cross section, 10 pts, INVALID (relief=T, banks=F)) - positive slope diagonal", {
#   ID_COL       <- "hy_id"
#   NUM_CS_PTS   <- 10
#   CS_LENGTH    <- 100
#   REL_DIST     <- seq(0, 1, length.out=NUM_CS_PTS+1)[2:(NUM_CS_PTS+1)]
#   Z_VALS       <- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) 
#   
#   cs <- data.frame(
#     hy_id             = rep("A", NUM_CS_PTS),
#     cs_id             = rep(1, NUM_CS_PTS),
#     pt_id             = 1:NUM_CS_PTS,
#     cs_lengthm        = rep(CS_LENGTH, NUM_CS_PTS),
#     relative_distance = REL_DIST,
#     Z                 = Z_VALS
#   )
#   
#   cpts <- classify_points(cs, crosswalk_id = ID_COL)
#   # cpts <- classify_points(cs, crosswalk_id = ID_COL)
#   
#   Z_VALS %>% plot()
#   cpts$Z %>% plot()
#   cpts$point_type
#   
#   expected_point_types <- c("left_bank", "channel", "channel", 
#                             "bottom", 
#                             "channel", "channel", "channel", 
#                             "channel", "channel", "right_bank")
#   
#   # correct point types
#   testthat::expect_true(
#     all(cpts$point_type == expected_point_types)
#   )
#   
#   # correct left bank value
#   testthat::expect_true(
#     all(cpts$left_bank == 1)
#   )
#   
#   # correct right bank value
#   testthat::expect_true(
#     all(cpts$right_bank == 10)
#   )
#   
#   # correct bottom value
#   testthat::expect_true(
#     all(cpts$bottom == 4)
#   )
#   
#   # correct has relief (TRUE)
#   testthat::expect_true(
#     all(cpts$has_relief)
#   )
#   
#   # correct valid_banks (FALSE)
#   testthat::expect_false(
#     all(cpts$valid_banks)
#   )
#   
# })
# # NOTE: Cross section shape:
# # \
# #  \
# #   \
# #    \
# #     \
# #      \
# testthat::test_that("'classify_points' - (1 cross section, 10 pts, INVALID (relief=T, banks=F)) - negative slope diagonal", {
#   ID_COL       <- "hy_id"
#   NUM_CS_PTS   <- 10
#   CS_LENGTH    <- 100
#   REL_DIST     <- seq(0, 1, length.out=NUM_CS_PTS+1)[2:(NUM_CS_PTS+1)]
#   Z_VALS       <- NUM_CS_PTS:1
#   
#   cs <- data.frame(
#     hy_id             = rep("A", NUM_CS_PTS),
#     cs_id             = rep(1, NUM_CS_PTS),
#     pt_id             = 1:NUM_CS_PTS,
#     cs_lengthm        = rep(CS_LENGTH, NUM_CS_PTS),
#     relative_distance = REL_DIST,
#     Z                 = Z_VALS
#   )
#   
#   cpts <- classify_points(cs, crosswalk_id = ID_COL)
#   # cpts <- classify_points(cs, crosswalk_id = ID_COL)
#   
#   # Z_VALS %>% plot()
#   # cpts$Z %>% plot()
#   # cpts$point_type
#   
#   expected_point_types <- c("left_bank", "channel", "channel", "channel", "channel", "channel",
#                             "bottom", 
#                             "channel",  "right_bank", "right_bank")
#   
#   # correct point types
#   testthat::expect_true(
#     all(cpts$point_type == expected_point_types)
#   )
#   
#   # correct left bank value
#   testthat::expect_true(
#     all(cpts$left_bank == 10)
#   )
#   
#   # correct right bank value
#   testthat::expect_true(
#     all(cpts$right_bank == 2)
#   )
#   
#   # correct bottom value
#   testthat::expect_true(
#     all(cpts$bottom == 4)
#   )
#   
#   # correct has relief (TRUE)
#   testthat::expect_true(
#     all(cpts$has_relief)
#   )
#   
#   # correct valid_banks (FALSE)
#   testthat::expect_false(
#     all(cpts$valid_banks)
#   )
#   
# })
# 
# # TODO: FLAT cross section
# # NOTE: Cross section shape:
# # --------------------
# testthat::test_that("'classify_points' - (1 cross section, 10 pts, 'flat line', INVALID (relief=F, banks=F)) - flat line", {
#   ID_COL       <- "hy_id"
#   NUM_CS_PTS   <- 10
#   CS_LENGTH    <- 100
#   REL_DIST     <- seq(0, 1, length.out=NUM_CS_PTS+1)[2:(NUM_CS_PTS+1)]
#   Z_VALS       <- rep(1, NUM_CS_PTS)
#   
#   cs <- data.frame(
#     hy_id             = rep("A", NUM_CS_PTS),
#     cs_id             = rep(1, NUM_CS_PTS),
#     pt_id             = 1:NUM_CS_PTS,
#     cs_lengthm        = rep(CS_LENGTH, NUM_CS_PTS),
#     relative_distance = REL_DIST,
#     Z                 = Z_VALS
#   )
#   
#   cpts <- classify_points(cs, crosswalk_id = ID_COL)
#   # cpts <- classify_points(cs, crosswalk_id = ID_COL)
#   
#   Z_VALS %>% plot()
#   cpts$Z %>% plot()
#   cpts$point_type
#   
#   expected_point_types <- c("left_bank", "left_bank", "channel", "bottom", "bottom", "bottom",
#                             "bottom", 
#                             "channel",  "right_bank", "right_bank")
#   
#   # correct point types
#   testthat::expect_true(
#     all(cpts$point_type == expected_point_types)
#   )
#   
#   # correct left bank value
#   testthat::expect_true(
#     all(cpts$left_bank == 1)
#   )
#   
#   # correct right bank value
#   testthat::expect_true(
#     all(cpts$right_bank == 1)
#   )
#   
#   # correct bottom value
#   testthat::expect_true(
#     all(cpts$bottom == 1)
#   )
#   
#   # correct has relief (FALSE)
#   testthat::expect_false(
#     all(cpts$has_relief)
#   )
#   
#   # correct valid_banks (FALSE)
#   testthat::expect_false(
#     all(cpts$valid_banks)
#   )
#   
# })
# 
# # TODO: FLAT cross section w/ single RIGHT BANK
# # NOTE: Cross section shape:
# #                      /
# # --------------------
# testthat::test_that("'classify_points' - (1 cross section, 10 pts, 'flat line w/ RIGHT BANK', INVALID (relief=T, banks=F)) - flat line", {
#   ID_COL       <- "hy_id"
#   NUM_CS_PTS   <- 10
#   CS_LENGTH    <- 100
#   REL_DIST     <- seq(0, 1, length.out=NUM_CS_PTS+1)[2:(NUM_CS_PTS+1)]
#   Z_VALS       <- c(rep(1, NUM_CS_PTS - 1), 2)
#   
#   cs <- data.frame(
#     hy_id             = rep("A", NUM_CS_PTS),
#     cs_id             = rep(1, NUM_CS_PTS),
#     pt_id             = 1:NUM_CS_PTS,
#     cs_lengthm        = rep(CS_LENGTH, NUM_CS_PTS),
#     relative_distance = REL_DIST,
#     Z                 = Z_VALS
#   )
#   
#   cpts <- classify_points(cs, crosswalk_id = ID_COL)
#   # cpts <- classify_points(cs, crosswalk_id = ID_COL)
#   
#   Z_VALS %>% plot()
#   cpts$Z %>% plot()
#   cpts$point_type
#   
#   expected_point_types <- c("left_bank", "left_bank", "channel", "bottom", "bottom", "bottom",
#                             "bottom", 
#                             "channel",  "channel", "right_bank")
#   
#   # correct point types
#   testthat::expect_true(
#     all(cpts$point_type == expected_point_types)
#   )
#   
#   # correct left bank value
#   testthat::expect_true(
#     all(cpts$left_bank == 1)
#   )
#   
#   # correct right bank value
#   testthat::expect_true(
#     all(cpts$right_bank == 2)
#   )
#   
#   # correct bottom value
#   testthat::expect_true(
#     all(cpts$bottom == 1)
#   )
#   
#   # correct has relief (FALSE)
#   testthat::expect_true(
#     all(cpts$has_relief)
#   )
#   
#   # correct valid_banks (FALSE)
#   testthat::expect_false(
#     all(cpts$valid_banks)
#   )
#   
# })
# 
# # TODO: FLAT cross section w/ single LEFT BANK
# # NOTE: Cross section shape:
# # \                    
# #  --------------------
# testthat::test_that("'classify_points' - (1 cross section, 10 pts, 'flat line w/ LEFT BANK', INVALID (relief=T, banks=F)) - flat line", {
#   ID_COL       <- "hy_id"
#   NUM_CS_PTS   <- 10
#   CS_LENGTH    <- 100
#   REL_DIST     <- seq(0, 1, length.out=NUM_CS_PTS+1)[2:(NUM_CS_PTS+1)]
#   Z_VALS       <- c(2, rep(1, NUM_CS_PTS - 1))
#   
#   cs <- data.frame(
#     hy_id             = rep("A", NUM_CS_PTS),
#     cs_id             = rep(1, NUM_CS_PTS),
#     pt_id             = 1:NUM_CS_PTS,
#     cs_lengthm        = rep(CS_LENGTH, NUM_CS_PTS),
#     relative_distance = REL_DIST,
#     Z                 = Z_VALS
#   )
#   
#   cpts <- classify_points(cs, crosswalk_id = ID_COL)
#   # cpts <- classify_points(cs, crosswalk_id = ID_COL)
#   
#   Z_VALS %>% plot()
#   cpts$Z %>% plot()
#   cpts$point_type
#   
#   expected_point_types <- c("left_bank", "channel", "channel", "bottom", "bottom", "bottom",
#                             "bottom", 
#                             "channel",  "right_bank", "right_bank")
#   
#   # correct point types
#   testthat::expect_true(
#     all(cpts$point_type == expected_point_types)
#   )
#   
#   # correct left bank value
#   testthat::expect_true(
#     all(cpts$left_bank == 2)
#   )
#   
#   # correct right bank value
#   testthat::expect_true(
#     all(cpts$right_bank == 1)
#   )
#   
#   # correct bottom value
#   testthat::expect_true(
#     all(cpts$bottom == 1)
#   )
#   
#   # correct has relief (FALSE)
#   testthat::expect_true(
#     all(cpts$has_relief)
#   )
#   
#   # correct valid_banks (FALSE)
#   testthat::expect_false(
#     all(cpts$valid_banks)
#   )
#   
# })
# 
# testthat::test_that("'classify_points' - (2 cross section, both VALID (relief=T, banks=T)) - left_bank above bottm, flat left channel, flat bottom, flat right channel, and right_bank above bottom", {
#   ID_COL <- "hy_id"
#   
#   ideal_pts1 <-
#     data.frame(
#       hy_id      = c("A", "A", "A", "A", "A", "A", "A", "A", "A", "A"),
#       cs_id      = c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1),
#       pt_id             = c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10),
#       cs_lengthm        = c(100, 100, 100, 100, 100, 100, 100, 100, 100, 100),
#       relative_distance = c(0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9),
#       # point_type = c('left_bank', 'left_bank', 'channel', 'channel', 'bottom', 'bottom', 'channel', 'channel', 'right_bank', 'right_bank'),
#       Z          = c(9, 7, 5, 5, 2, 2, 5, 5, 7, 9)
#     )
#   
#   # classify_z_pts(ideal_pts1$Z, 10)
#   # hydrofabric3D::classify_points(ideal_pts1, crosswalk_id = "hy_id")$point_type
#   
#   # Identical cross section as above with different "hy_id"
#   ideal_pts2 <-
#     data.frame(
#       hy_id      = c("B", "B", "B", "B", "B", "B", "B", "B", "B", "B"),
#       cs_id      = c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1),
#       pt_id             = c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10),
#       cs_lengthm        = c(100, 100, 100, 100, 100, 100, 100, 100, 100, 100),
#       relative_distance = c(0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9),
#       # point_type = c('left_bank', 'left_bank', 'channel', 'channel', 'bottom', 'bottom', 'channel', 'channel', 'right_bank', 'right_bank'),
#       Z          = c(9, 7, 5, 5, 2, 2, 5, 5, 7, 9)
#     )
#   
#   two_cs <- 
#     dplyr::bind_rows(
#       ideal_pts1,
#       ideal_pts2
#     )
#   
#   # plot(two_cs$Z~two_cs$pt_id)
#   
#   cpts <- classify_points(two_cs, crosswalk_id = ID_COL)
#   
#   expected_point_types <- c('left_bank', 'channel', 'channel', 'channel', 
#                             'bottom', 'bottom', 
#                             'channel', 'channel', 'channel', 'right_bank')
#   
#   # make sure both hy_ids got correct classification
#   testthat::expect_true(
#     all(dplyr::filter(cpts, hy_id == "A")$point_type == expected_point_types)
#   )
#   
#   testthat::expect_true(
#     all(dplyr::filter(cpts, hy_id == "B")$point_type == expected_point_types)
#   )
#   
#   # make sure both HY IDs have relief
#   testthat::expect_true(
#     all(dplyr::filter(cpts, hy_id == "A")$has_relief)
#   )
#   
#   testthat::expect_true(
#     all(dplyr::filter(cpts, hy_id == "B")$has_relief)
#   )
#   
#   # make sure both HY IDs have valid banks
#   testthat::expect_true(
#     all(dplyr::filter(cpts, hy_id == "A")$valid_banks)
#   )
#   
#   testthat::expect_true(
#     all(dplyr::filter(cpts, hy_id == "B")$valid_banks)
#   )
#   
#   # make sure all unique tmp_ids were preserved 
#   testthat::expect_true(
#     all(
#       hydrofabric3D::get_unique_tmp_ids(cpts) %in% hydrofabric3D::get_unique_tmp_ids(two_cs) 
#     )
#   )
#   
#   
#   
# })
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
